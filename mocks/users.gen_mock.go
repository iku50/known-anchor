// Code generated by MockGen. DO NOT EDIT.
// Source: ./dal/db/dao/users.gen.go

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	dao "known-anchors/dal/db/dao"
	model "known-anchors/dal/db/model"
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
	gen "gorm.io/gen"
	field "gorm.io/gen/field"
	gorm "gorm.io/gorm"
	clause "gorm.io/gorm/clause"
	schema "gorm.io/gorm/schema"
)

// MockIUserDo is a mock of IUserDo interface.
type MockIUserDo struct {
	ctrl     *gomock.Controller
	recorder *MockIUserDoMockRecorder
}

// MockIUserDoMockRecorder is the mock recorder for MockIUserDo.
type MockIUserDoMockRecorder struct {
	mock *MockIUserDo
}

// NewMockIUserDo creates a new mock instance.
func NewMockIUserDo(ctrl *gomock.Controller) *MockIUserDo {
	mock := &MockIUserDo{ctrl: ctrl}
	mock.recorder = &MockIUserDoMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIUserDo) EXPECT() *MockIUserDoMockRecorder {
	return m.recorder
}

// As mocks base method.
func (m *MockIUserDo) As(alias string) gen.Dao {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "As", alias)
	ret0, _ := ret[0].(gen.Dao)
	return ret0
}

// As indicates an expected call of As.
func (mr *MockIUserDoMockRecorder) As(alias interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "As", reflect.TypeOf((*MockIUserDo)(nil).As), alias)
}

// Assign mocks base method.
func (m *MockIUserDo) Assign(attrs ...field.AssignExpr) dao.IUserDo {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range attrs {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Assign", varargs...)
	ret0, _ := ret[0].(dao.IUserDo)
	return ret0
}

// Assign indicates an expected call of Assign.
func (mr *MockIUserDoMockRecorder) Assign(attrs ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Assign", reflect.TypeOf((*MockIUserDo)(nil).Assign), attrs...)
}

// Attrs mocks base method.
func (m *MockIUserDo) Attrs(attrs ...field.AssignExpr) dao.IUserDo {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range attrs {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Attrs", varargs...)
	ret0, _ := ret[0].(dao.IUserDo)
	return ret0
}

// Attrs indicates an expected call of Attrs.
func (mr *MockIUserDoMockRecorder) Attrs(attrs ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Attrs", reflect.TypeOf((*MockIUserDo)(nil).Attrs), attrs...)
}

// BeCond mocks base method.
func (m *MockIUserDo) BeCond() interface{} {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BeCond")
	ret0, _ := ret[0].(interface{})
	return ret0
}

// BeCond indicates an expected call of BeCond.
func (mr *MockIUserDoMockRecorder) BeCond() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BeCond", reflect.TypeOf((*MockIUserDo)(nil).BeCond))
}

// Clauses mocks base method.
func (m *MockIUserDo) Clauses(conds ...clause.Expression) dao.IUserDo {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range conds {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Clauses", varargs...)
	ret0, _ := ret[0].(dao.IUserDo)
	return ret0
}

// Clauses indicates an expected call of Clauses.
func (mr *MockIUserDoMockRecorder) Clauses(conds ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Clauses", reflect.TypeOf((*MockIUserDo)(nil).Clauses), conds...)
}

// Columns mocks base method.
func (m *MockIUserDo) Columns(cols ...field.Expr) gen.Columns {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range cols {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Columns", varargs...)
	ret0, _ := ret[0].(gen.Columns)
	return ret0
}

// Columns indicates an expected call of Columns.
func (mr *MockIUserDoMockRecorder) Columns(cols ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Columns", reflect.TypeOf((*MockIUserDo)(nil).Columns), cols...)
}

// CondError mocks base method.
func (m *MockIUserDo) CondError() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CondError")
	ret0, _ := ret[0].(error)
	return ret0
}

// CondError indicates an expected call of CondError.
func (mr *MockIUserDoMockRecorder) CondError() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CondError", reflect.TypeOf((*MockIUserDo)(nil).CondError))
}

// Count mocks base method.
func (m *MockIUserDo) Count() (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Count")
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Count indicates an expected call of Count.
func (mr *MockIUserDoMockRecorder) Count() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Count", reflect.TypeOf((*MockIUserDo)(nil).Count))
}

// Create mocks base method.
func (m *MockIUserDo) Create(values ...*model.User) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range values {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Create", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Create indicates an expected call of Create.
func (mr *MockIUserDoMockRecorder) Create(values ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockIUserDo)(nil).Create), values...)
}

// CreateInBatches mocks base method.
func (m *MockIUserDo) CreateInBatches(values []*model.User, batchSize int) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateInBatches", values, batchSize)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateInBatches indicates an expected call of CreateInBatches.
func (mr *MockIUserDoMockRecorder) CreateInBatches(values, batchSize interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateInBatches", reflect.TypeOf((*MockIUserDo)(nil).CreateInBatches), values, batchSize)
}

// Debug mocks base method.
func (m *MockIUserDo) Debug() dao.IUserDo {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Debug")
	ret0, _ := ret[0].(dao.IUserDo)
	return ret0
}

// Debug indicates an expected call of Debug.
func (mr *MockIUserDoMockRecorder) Debug() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Debug", reflect.TypeOf((*MockIUserDo)(nil).Debug))
}

// Delete mocks base method.
func (m *MockIUserDo) Delete(arg0 ...*model.User) (gen.ResultInfo, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range arg0 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Delete", varargs...)
	ret0, _ := ret[0].(gen.ResultInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Delete indicates an expected call of Delete.
func (mr *MockIUserDoMockRecorder) Delete(arg0 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockIUserDo)(nil).Delete), arg0...)
}

// DeleteByEmail mocks base method.
func (m *MockIUserDo) DeleteByEmail(email string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteByEmail", email)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteByEmail indicates an expected call of DeleteByEmail.
func (mr *MockIUserDoMockRecorder) DeleteByEmail(email interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteByEmail", reflect.TypeOf((*MockIUserDo)(nil).DeleteByEmail), email)
}

// Distinct mocks base method.
func (m *MockIUserDo) Distinct(cols ...field.Expr) dao.IUserDo {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range cols {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Distinct", varargs...)
	ret0, _ := ret[0].(dao.IUserDo)
	return ret0
}

// Distinct indicates an expected call of Distinct.
func (mr *MockIUserDoMockRecorder) Distinct(cols ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Distinct", reflect.TypeOf((*MockIUserDo)(nil).Distinct), cols...)
}

// Find mocks base method.
func (m *MockIUserDo) Find() ([]*model.User, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Find")
	ret0, _ := ret[0].([]*model.User)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Find indicates an expected call of Find.
func (mr *MockIUserDoMockRecorder) Find() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Find", reflect.TypeOf((*MockIUserDo)(nil).Find))
}

// FindByEmail mocks base method.
func (m *MockIUserDo) FindByEmail(email string) (model.User, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindByEmail", email)
	ret0, _ := ret[0].(model.User)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindByEmail indicates an expected call of FindByEmail.
func (mr *MockIUserDoMockRecorder) FindByEmail(email interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindByEmail", reflect.TypeOf((*MockIUserDo)(nil).FindByEmail), email)
}

// FindByID mocks base method.
func (m *MockIUserDo) FindByID(id uint) (model.User, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindByID", id)
	ret0, _ := ret[0].(model.User)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindByID indicates an expected call of FindByID.
func (mr *MockIUserDoMockRecorder) FindByID(id interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindByID", reflect.TypeOf((*MockIUserDo)(nil).FindByID), id)
}

// FindByPage mocks base method.
func (m *MockIUserDo) FindByPage(offset, limit int) ([]*model.User, int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindByPage", offset, limit)
	ret0, _ := ret[0].([]*model.User)
	ret1, _ := ret[1].(int64)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// FindByPage indicates an expected call of FindByPage.
func (mr *MockIUserDoMockRecorder) FindByPage(offset, limit interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindByPage", reflect.TypeOf((*MockIUserDo)(nil).FindByPage), offset, limit)
}

// FindInBatch mocks base method.
func (m *MockIUserDo) FindInBatch(batchSize int, fc func(gen.Dao, int) error) ([]*model.User, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindInBatch", batchSize, fc)
	ret0, _ := ret[0].([]*model.User)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindInBatch indicates an expected call of FindInBatch.
func (mr *MockIUserDoMockRecorder) FindInBatch(batchSize, fc interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindInBatch", reflect.TypeOf((*MockIUserDo)(nil).FindInBatch), batchSize, fc)
}

// FindInBatches mocks base method.
func (m *MockIUserDo) FindInBatches(result *[]*model.User, batchSize int, fc func(gen.Dao, int) error) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindInBatches", result, batchSize, fc)
	ret0, _ := ret[0].(error)
	return ret0
}

// FindInBatches indicates an expected call of FindInBatches.
func (mr *MockIUserDoMockRecorder) FindInBatches(result, batchSize, fc interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindInBatches", reflect.TypeOf((*MockIUserDo)(nil).FindInBatches), result, batchSize, fc)
}

// First mocks base method.
func (m *MockIUserDo) First() (*model.User, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "First")
	ret0, _ := ret[0].(*model.User)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// First indicates an expected call of First.
func (mr *MockIUserDoMockRecorder) First() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "First", reflect.TypeOf((*MockIUserDo)(nil).First))
}

// FirstOrCreate mocks base method.
func (m *MockIUserDo) FirstOrCreate() (*model.User, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FirstOrCreate")
	ret0, _ := ret[0].(*model.User)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FirstOrCreate indicates an expected call of FirstOrCreate.
func (mr *MockIUserDoMockRecorder) FirstOrCreate() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FirstOrCreate", reflect.TypeOf((*MockIUserDo)(nil).FirstOrCreate))
}

// FirstOrInit mocks base method.
func (m *MockIUserDo) FirstOrInit() (*model.User, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FirstOrInit")
	ret0, _ := ret[0].(*model.User)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FirstOrInit indicates an expected call of FirstOrInit.
func (mr *MockIUserDoMockRecorder) FirstOrInit() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FirstOrInit", reflect.TypeOf((*MockIUserDo)(nil).FirstOrInit))
}

// Group mocks base method.
func (m *MockIUserDo) Group(cols ...field.Expr) dao.IUserDo {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range cols {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Group", varargs...)
	ret0, _ := ret[0].(dao.IUserDo)
	return ret0
}

// Group indicates an expected call of Group.
func (mr *MockIUserDoMockRecorder) Group(cols ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Group", reflect.TypeOf((*MockIUserDo)(nil).Group), cols...)
}

// Having mocks base method.
func (m *MockIUserDo) Having(conds ...gen.Condition) dao.IUserDo {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range conds {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Having", varargs...)
	ret0, _ := ret[0].(dao.IUserDo)
	return ret0
}

// Having indicates an expected call of Having.
func (mr *MockIUserDoMockRecorder) Having(conds ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Having", reflect.TypeOf((*MockIUserDo)(nil).Having), conds...)
}

// Join mocks base method.
func (m *MockIUserDo) Join(table schema.Tabler, on ...field.Expr) dao.IUserDo {
	m.ctrl.T.Helper()
	varargs := []interface{}{table}
	for _, a := range on {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Join", varargs...)
	ret0, _ := ret[0].(dao.IUserDo)
	return ret0
}

// Join indicates an expected call of Join.
func (mr *MockIUserDoMockRecorder) Join(table interface{}, on ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{table}, on...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Join", reflect.TypeOf((*MockIUserDo)(nil).Join), varargs...)
}

// Joins mocks base method.
func (m *MockIUserDo) Joins(fields ...field.RelationField) dao.IUserDo {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range fields {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Joins", varargs...)
	ret0, _ := ret[0].(dao.IUserDo)
	return ret0
}

// Joins indicates an expected call of Joins.
func (mr *MockIUserDoMockRecorder) Joins(fields ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Joins", reflect.TypeOf((*MockIUserDo)(nil).Joins), fields...)
}

// Last mocks base method.
func (m *MockIUserDo) Last() (*model.User, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Last")
	ret0, _ := ret[0].(*model.User)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Last indicates an expected call of Last.
func (mr *MockIUserDoMockRecorder) Last() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Last", reflect.TypeOf((*MockIUserDo)(nil).Last))
}

// LeftJoin mocks base method.
func (m *MockIUserDo) LeftJoin(table schema.Tabler, on ...field.Expr) dao.IUserDo {
	m.ctrl.T.Helper()
	varargs := []interface{}{table}
	for _, a := range on {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "LeftJoin", varargs...)
	ret0, _ := ret[0].(dao.IUserDo)
	return ret0
}

// LeftJoin indicates an expected call of LeftJoin.
func (mr *MockIUserDoMockRecorder) LeftJoin(table interface{}, on ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{table}, on...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LeftJoin", reflect.TypeOf((*MockIUserDo)(nil).LeftJoin), varargs...)
}

// Limit mocks base method.
func (m *MockIUserDo) Limit(limit int) dao.IUserDo {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Limit", limit)
	ret0, _ := ret[0].(dao.IUserDo)
	return ret0
}

// Limit indicates an expected call of Limit.
func (mr *MockIUserDoMockRecorder) Limit(limit interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Limit", reflect.TypeOf((*MockIUserDo)(nil).Limit), limit)
}

// Not mocks base method.
func (m *MockIUserDo) Not(conds ...gen.Condition) dao.IUserDo {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range conds {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Not", varargs...)
	ret0, _ := ret[0].(dao.IUserDo)
	return ret0
}

// Not indicates an expected call of Not.
func (mr *MockIUserDoMockRecorder) Not(conds ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Not", reflect.TypeOf((*MockIUserDo)(nil).Not), conds...)
}

// Offset mocks base method.
func (m *MockIUserDo) Offset(offset int) dao.IUserDo {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Offset", offset)
	ret0, _ := ret[0].(dao.IUserDo)
	return ret0
}

// Offset indicates an expected call of Offset.
func (mr *MockIUserDoMockRecorder) Offset(offset interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Offset", reflect.TypeOf((*MockIUserDo)(nil).Offset), offset)
}

// Omit mocks base method.
func (m *MockIUserDo) Omit(cols ...field.Expr) dao.IUserDo {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range cols {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Omit", varargs...)
	ret0, _ := ret[0].(dao.IUserDo)
	return ret0
}

// Omit indicates an expected call of Omit.
func (mr *MockIUserDoMockRecorder) Omit(cols ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Omit", reflect.TypeOf((*MockIUserDo)(nil).Omit), cols...)
}

// Or mocks base method.
func (m *MockIUserDo) Or(conds ...gen.Condition) dao.IUserDo {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range conds {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Or", varargs...)
	ret0, _ := ret[0].(dao.IUserDo)
	return ret0
}

// Or indicates an expected call of Or.
func (mr *MockIUserDoMockRecorder) Or(conds ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Or", reflect.TypeOf((*MockIUserDo)(nil).Or), conds...)
}

// Order mocks base method.
func (m *MockIUserDo) Order(conds ...field.Expr) dao.IUserDo {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range conds {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Order", varargs...)
	ret0, _ := ret[0].(dao.IUserDo)
	return ret0
}

// Order indicates an expected call of Order.
func (mr *MockIUserDoMockRecorder) Order(conds ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Order", reflect.TypeOf((*MockIUserDo)(nil).Order), conds...)
}

// Pluck mocks base method.
func (m *MockIUserDo) Pluck(column field.Expr, dest interface{}) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Pluck", column, dest)
	ret0, _ := ret[0].(error)
	return ret0
}

// Pluck indicates an expected call of Pluck.
func (mr *MockIUserDoMockRecorder) Pluck(column, dest interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Pluck", reflect.TypeOf((*MockIUserDo)(nil).Pluck), column, dest)
}

// Preload mocks base method.
func (m *MockIUserDo) Preload(fields ...field.RelationField) dao.IUserDo {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range fields {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Preload", varargs...)
	ret0, _ := ret[0].(dao.IUserDo)
	return ret0
}

// Preload indicates an expected call of Preload.
func (mr *MockIUserDoMockRecorder) Preload(fields ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Preload", reflect.TypeOf((*MockIUserDo)(nil).Preload), fields...)
}

// ReadDB mocks base method.
func (m *MockIUserDo) ReadDB() dao.IUserDo {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadDB")
	ret0, _ := ret[0].(dao.IUserDo)
	return ret0
}

// ReadDB indicates an expected call of ReadDB.
func (mr *MockIUserDoMockRecorder) ReadDB() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadDB", reflect.TypeOf((*MockIUserDo)(nil).ReadDB))
}

// ReplaceDB mocks base method.
func (m *MockIUserDo) ReplaceDB(db *gorm.DB) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "ReplaceDB", db)
}

// ReplaceDB indicates an expected call of ReplaceDB.
func (mr *MockIUserDoMockRecorder) ReplaceDB(db interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReplaceDB", reflect.TypeOf((*MockIUserDo)(nil).ReplaceDB), db)
}

// Returning mocks base method.
func (m *MockIUserDo) Returning(value interface{}, columns ...string) dao.IUserDo {
	m.ctrl.T.Helper()
	varargs := []interface{}{value}
	for _, a := range columns {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Returning", varargs...)
	ret0, _ := ret[0].(dao.IUserDo)
	return ret0
}

// Returning indicates an expected call of Returning.
func (mr *MockIUserDoMockRecorder) Returning(value interface{}, columns ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{value}, columns...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Returning", reflect.TypeOf((*MockIUserDo)(nil).Returning), varargs...)
}

// RightJoin mocks base method.
func (m *MockIUserDo) RightJoin(table schema.Tabler, on ...field.Expr) dao.IUserDo {
	m.ctrl.T.Helper()
	varargs := []interface{}{table}
	for _, a := range on {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "RightJoin", varargs...)
	ret0, _ := ret[0].(dao.IUserDo)
	return ret0
}

// RightJoin indicates an expected call of RightJoin.
func (mr *MockIUserDoMockRecorder) RightJoin(table interface{}, on ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{table}, on...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RightJoin", reflect.TypeOf((*MockIUserDo)(nil).RightJoin), varargs...)
}

// Save mocks base method.
func (m *MockIUserDo) Save(values ...*model.User) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range values {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Save", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Save indicates an expected call of Save.
func (mr *MockIUserDoMockRecorder) Save(values ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Save", reflect.TypeOf((*MockIUserDo)(nil).Save), values...)
}

// Scan mocks base method.
func (m *MockIUserDo) Scan(result interface{}) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Scan", result)
	ret0, _ := ret[0].(error)
	return ret0
}

// Scan indicates an expected call of Scan.
func (mr *MockIUserDoMockRecorder) Scan(result interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Scan", reflect.TypeOf((*MockIUserDo)(nil).Scan), result)
}

// ScanByPage mocks base method.
func (m *MockIUserDo) ScanByPage(result interface{}, offset, limit int) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ScanByPage", result, offset, limit)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ScanByPage indicates an expected call of ScanByPage.
func (mr *MockIUserDoMockRecorder) ScanByPage(result, offset, limit interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ScanByPage", reflect.TypeOf((*MockIUserDo)(nil).ScanByPage), result, offset, limit)
}

// Scopes mocks base method.
func (m *MockIUserDo) Scopes(funcs ...func(gen.Dao) gen.Dao) dao.IUserDo {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range funcs {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Scopes", varargs...)
	ret0, _ := ret[0].(dao.IUserDo)
	return ret0
}

// Scopes indicates an expected call of Scopes.
func (mr *MockIUserDoMockRecorder) Scopes(funcs ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Scopes", reflect.TypeOf((*MockIUserDo)(nil).Scopes), funcs...)
}

// Select mocks base method.
func (m *MockIUserDo) Select(conds ...field.Expr) dao.IUserDo {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range conds {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Select", varargs...)
	ret0, _ := ret[0].(dao.IUserDo)
	return ret0
}

// Select indicates an expected call of Select.
func (mr *MockIUserDoMockRecorder) Select(conds ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Select", reflect.TypeOf((*MockIUserDo)(nil).Select), conds...)
}

// Session mocks base method.
func (m *MockIUserDo) Session(config *gorm.Session) dao.IUserDo {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Session", config)
	ret0, _ := ret[0].(dao.IUserDo)
	return ret0
}

// Session indicates an expected call of Session.
func (mr *MockIUserDoMockRecorder) Session(config interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Session", reflect.TypeOf((*MockIUserDo)(nil).Session), config)
}

// TableName mocks base method.
func (m *MockIUserDo) TableName() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TableName")
	ret0, _ := ret[0].(string)
	return ret0
}

// TableName indicates an expected call of TableName.
func (mr *MockIUserDoMockRecorder) TableName() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TableName", reflect.TypeOf((*MockIUserDo)(nil).TableName))
}

// Take mocks base method.
func (m *MockIUserDo) Take() (*model.User, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Take")
	ret0, _ := ret[0].(*model.User)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Take indicates an expected call of Take.
func (mr *MockIUserDoMockRecorder) Take() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Take", reflect.TypeOf((*MockIUserDo)(nil).Take))
}

// UnderlyingDB mocks base method.
func (m *MockIUserDo) UnderlyingDB() *gorm.DB {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UnderlyingDB")
	ret0, _ := ret[0].(*gorm.DB)
	return ret0
}

// UnderlyingDB indicates an expected call of UnderlyingDB.
func (mr *MockIUserDoMockRecorder) UnderlyingDB() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UnderlyingDB", reflect.TypeOf((*MockIUserDo)(nil).UnderlyingDB))
}

// Unscoped mocks base method.
func (m *MockIUserDo) Unscoped() dao.IUserDo {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Unscoped")
	ret0, _ := ret[0].(dao.IUserDo)
	return ret0
}

// Unscoped indicates an expected call of Unscoped.
func (mr *MockIUserDoMockRecorder) Unscoped() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Unscoped", reflect.TypeOf((*MockIUserDo)(nil).Unscoped))
}

// Update mocks base method.
func (m *MockIUserDo) Update(column field.Expr, value interface{}) (gen.ResultInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Update", column, value)
	ret0, _ := ret[0].(gen.ResultInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Update indicates an expected call of Update.
func (mr *MockIUserDoMockRecorder) Update(column, value interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockIUserDo)(nil).Update), column, value)
}

// UpdateActivatedByEmail mocks base method.
func (m *MockIUserDo) UpdateActivatedByEmail(email string, activated bool) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateActivatedByEmail", email, activated)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateActivatedByEmail indicates an expected call of UpdateActivatedByEmail.
func (mr *MockIUserDoMockRecorder) UpdateActivatedByEmail(email, activated interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateActivatedByEmail", reflect.TypeOf((*MockIUserDo)(nil).UpdateActivatedByEmail), email, activated)
}

// UpdateByID mocks base method.
func (m *MockIUserDo) UpdateByID(id uint, email, username, password string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateByID", id, email, username, password)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateByID indicates an expected call of UpdateByID.
func (mr *MockIUserDoMockRecorder) UpdateByID(id, email, username, password interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateByID", reflect.TypeOf((*MockIUserDo)(nil).UpdateByID), id, email, username, password)
}

// UpdateColumn mocks base method.
func (m *MockIUserDo) UpdateColumn(column field.Expr, value interface{}) (gen.ResultInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateColumn", column, value)
	ret0, _ := ret[0].(gen.ResultInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UpdateColumn indicates an expected call of UpdateColumn.
func (mr *MockIUserDoMockRecorder) UpdateColumn(column, value interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateColumn", reflect.TypeOf((*MockIUserDo)(nil).UpdateColumn), column, value)
}

// UpdateColumnSimple mocks base method.
func (m *MockIUserDo) UpdateColumnSimple(columns ...field.AssignExpr) (gen.ResultInfo, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range columns {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UpdateColumnSimple", varargs...)
	ret0, _ := ret[0].(gen.ResultInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UpdateColumnSimple indicates an expected call of UpdateColumnSimple.
func (mr *MockIUserDoMockRecorder) UpdateColumnSimple(columns ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateColumnSimple", reflect.TypeOf((*MockIUserDo)(nil).UpdateColumnSimple), columns...)
}

// UpdateColumns mocks base method.
func (m *MockIUserDo) UpdateColumns(value interface{}) (gen.ResultInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateColumns", value)
	ret0, _ := ret[0].(gen.ResultInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UpdateColumns indicates an expected call of UpdateColumns.
func (mr *MockIUserDoMockRecorder) UpdateColumns(value interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateColumns", reflect.TypeOf((*MockIUserDo)(nil).UpdateColumns), value)
}

// UpdateFrom mocks base method.
func (m *MockIUserDo) UpdateFrom(q gen.SubQuery) gen.Dao {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateFrom", q)
	ret0, _ := ret[0].(gen.Dao)
	return ret0
}

// UpdateFrom indicates an expected call of UpdateFrom.
func (mr *MockIUserDoMockRecorder) UpdateFrom(q interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateFrom", reflect.TypeOf((*MockIUserDo)(nil).UpdateFrom), q)
}

// UpdateSimple mocks base method.
func (m *MockIUserDo) UpdateSimple(columns ...field.AssignExpr) (gen.ResultInfo, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range columns {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UpdateSimple", varargs...)
	ret0, _ := ret[0].(gen.ResultInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UpdateSimple indicates an expected call of UpdateSimple.
func (mr *MockIUserDoMockRecorder) UpdateSimple(columns ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateSimple", reflect.TypeOf((*MockIUserDo)(nil).UpdateSimple), columns...)
}

// Updates mocks base method.
func (m *MockIUserDo) Updates(value interface{}) (gen.ResultInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Updates", value)
	ret0, _ := ret[0].(gen.ResultInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Updates indicates an expected call of Updates.
func (mr *MockIUserDoMockRecorder) Updates(value interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Updates", reflect.TypeOf((*MockIUserDo)(nil).Updates), value)
}

// Where mocks base method.
func (m *MockIUserDo) Where(conds ...gen.Condition) dao.IUserDo {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range conds {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Where", varargs...)
	ret0, _ := ret[0].(dao.IUserDo)
	return ret0
}

// Where indicates an expected call of Where.
func (mr *MockIUserDoMockRecorder) Where(conds ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Where", reflect.TypeOf((*MockIUserDo)(nil).Where), conds...)
}

// WithContext mocks base method.
func (m *MockIUserDo) WithContext(ctx context.Context) dao.IUserDo {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WithContext", ctx)
	ret0, _ := ret[0].(dao.IUserDo)
	return ret0
}

// WithContext indicates an expected call of WithContext.
func (mr *MockIUserDoMockRecorder) WithContext(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithContext", reflect.TypeOf((*MockIUserDo)(nil).WithContext), ctx)
}

// WithResult mocks base method.
func (m *MockIUserDo) WithResult(fc func(gen.Dao)) gen.ResultInfo {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WithResult", fc)
	ret0, _ := ret[0].(gen.ResultInfo)
	return ret0
}

// WithResult indicates an expected call of WithResult.
func (mr *MockIUserDoMockRecorder) WithResult(fc interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithResult", reflect.TypeOf((*MockIUserDo)(nil).WithResult), fc)
}

// WriteDB mocks base method.
func (m *MockIUserDo) WriteDB() dao.IUserDo {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WriteDB")
	ret0, _ := ret[0].(dao.IUserDo)
	return ret0
}

// WriteDB indicates an expected call of WriteDB.
func (mr *MockIUserDoMockRecorder) WriteDB() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WriteDB", reflect.TypeOf((*MockIUserDo)(nil).WriteDB))
}

// underlyingDB mocks base method.
func (m *MockIUserDo) underlyingDB() *gorm.DB {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "underlyingDB")
	ret0, _ := ret[0].(*gorm.DB)
	return ret0
}

// underlyingDB indicates an expected call of underlyingDB.
func (mr *MockIUserDoMockRecorder) underlyingDB() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "underlyingDB", reflect.TypeOf((*MockIUserDo)(nil).underlyingDB))
}

// underlyingDO mocks base method.
func (m *MockIUserDo) underlyingDO() *gen.DO {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "underlyingDO")
	ret0, _ := ret[0].(*gen.DO)
	return ret0
}

// underlyingDO indicates an expected call of underlyingDO.
func (mr *MockIUserDoMockRecorder) underlyingDO() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "underlyingDO", reflect.TypeOf((*MockIUserDo)(nil).underlyingDO))
}
